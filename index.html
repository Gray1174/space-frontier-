<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Territory Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
    #flagMenu {
      position: absolute;
      display: none;
      width: 50px;
      height: 50px;
      background: #333;
      border: 2px solid #555;
      font-size: 28px;
      color: white;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="flagMenu">ðŸš©</div>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const flagMenu = document.getElementById("flagMenu");

    let TILE_SIZE = 4;
    let MAP_COLS = 300;
    let MAP_ROWS = 150;
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const map = [];
    const centerX = MAP_COLS / 2;
    const centerY = MAP_ROWS / 2;
    const maxDist = Math.min(centerX, centerY) * 0.9;

    // Generate map with natural island shape
    for (let y = 0; y < MAP_ROWS; y++) {
      const row = [];
      for (let x = 0; x < MAP_COLS; x++) {
        let dx = x - centerX;
        let dy = y - centerY;
        let dist = Math.sqrt(dx * dx + dy * dy);
        let noise = Math.random() * 10 - 5;
        let type = (dist + noise < maxDist) ? "land" : "water";
        row.push({ type, owner: null });
      }
      map.push(row);
    }

    let viewOffset = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragOffsetStart = { x: 0, y: 0 };
    let playerSpawned = false;

    function draw() {
      ctx.clearRect(0, 0, width, height);
      for (let y = 0; y < MAP_ROWS; y++) {
        for (let x = 0; x < MAP_COLS; x++) {
          let tile = map[y][x];
          if (tile.type === "water") ctx.fillStyle = "#3377cc";
          else if (tile.owner === "player") ctx.fillStyle = "blue";
          else ctx.fillStyle = "green";

          ctx.fillRect(
            x * TILE_SIZE + viewOffset.x,
            y * TILE_SIZE + viewOffset.y,
            TILE_SIZE,
            TILE_SIZE
          );
        }
      }
    }

    function worldToTile(x, y) {
      return {
        tx: Math.floor((x - viewOffset.x) / TILE_SIZE),
        ty: Math.floor((y - viewOffset.y) / TILE_SIZE)
      };
    }

    function openFlagMenu(x, y) {
      flagMenu.style.left = x + "px";
      flagMenu.style.top = y + "px";
      flagMenu.style.display = "flex";
    }

    function closeFlagMenu() {
      flagMenu.style.display = "none";
    }

    function spawnPlayer(tx, ty) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          let nx = tx + dx;
          let ny = ty + dy;
          if (
            nx >= 0 && ny >= 0 && nx < MAP_COLS && ny < MAP_ROWS &&
            map[ny][nx].type === "land"
          ) {
            map[ny][nx].owner = "player";
          }
        }
      }
      playerSpawned = true;
      closeFlagMenu();
      draw();
    }

    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      dragOffsetStart.x = viewOffset.x;
      dragOffsetStart.y = viewOffset.y;
    });

    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        viewOffset.x = dragOffsetStart.x + (e.clientX - dragStart.x);
        viewOffset.y = dragOffsetStart.y + (e.clientY - dragStart.y);
        draw();
      }
    });

    canvas.addEventListener("mouseup", () => {
      isDragging = false;
    });

    canvas.addEventListener("click", (e) => {
      if (!playerSpawned) {
        const { tx, ty } = worldToTile(e.clientX, e.clientY);
        if (map[ty] && map[ty][tx] && map[ty][tx].type === "land") {
          openFlagMenu(e.clientX, e.clientY);
          flagMenu.onclick = () => spawnPlayer(tx, ty);
        }
      }
    });

    // Touch support
    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        const t = e.touches[0];
        dragStart.x = t.clientX;
        dragStart.y = t.clientY;
        dragOffsetStart.x = viewOffset.x;
        dragOffsetStart.y = viewOffset.y;
        isDragging = true;
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      if (e.touches.length === 1 && isDragging) {
        const t = e.touches[0];
        viewOffset.x = dragOffsetStart.x + (t.clientX - dragStart.x);
        viewOffset.y = dragOffsetStart.y + (t.clientY - dragStart.y);
        draw();
      }
    });

    canvas.addEventListener("touchend", (e) => {
      isDragging = false;
      if (!playerSpawned && e.changedTouches.length === 1) {
        const t = e.changedTouches[0];
        const { tx, ty } = worldToTile(t.clientX, t.clientY);
        if (map[ty] && map[ty][tx] && map[ty][tx].type === "land") {
          openFlagMenu(t.clientX, t.clientY);
          flagMenu.onclick = () => spawnPlayer(tx, ty);
        }
      }
    });

    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      draw();
    });

    draw();
  </script>
</body>
</html>
