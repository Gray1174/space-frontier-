<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Territory Zoom Game</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #111;
  }
  canvas {
    display: block;
    touch-action: none;
  }
  #flagMenu {
    position: absolute;
    display: none;
    width: 30px;
    height: 30px;
    background: #333;
    border: 2px solid #555;
    font-size: 20px;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
    z-index: 10;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="flagMenu">ðŸš©</div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const flagMenu = document.getElementById("flagMenu");

let TILE_SIZE = 1;
const MAP_COLS = 600;
const MAP_ROWS = 300;

let width = window.innerWidth;
let height = window.innerHeight;

canvas.width = width;
canvas.height = height;

// Zoom & pan
let scale = 2;
let viewOffset = { x: 0, y: 0 };
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let dragOffsetStart = { x: 0, y: 0 };

const map = [];
const centerX = MAP_COLS / 2;
const centerY = MAP_ROWS / 2;
const maxDist = Math.min(centerX, centerY) * 0.85;

for (let y = 0; y < MAP_ROWS; y++) {
  const row = [];
  for (let x = 0; x < MAP_COLS; x++) {
    const dx = x - centerX;
    const dy = y - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy) + (Math.random() * 10 - 5);
    const type = dist < maxDist ? "land" : "water";
    row.push({ type, owner: null });
  }
  map.push(row);
}

let hasSpawned = false;
let pendingClaim = null;

function draw() {
  ctx.clearRect(0, 0, width, height);
  ctx.save();
  ctx.translate(viewOffset.x, viewOffset.y);
  ctx.scale(scale, scale);

  for (let y = 0; y < MAP_ROWS; y++) {
    for (let x = 0; x < MAP_COLS; x++) {
      const tile = map[y][x];
      if (tile.type === "water") ctx.fillStyle = "#3366cc";
      else if (tile.owner === "player") ctx.fillStyle = "#0066ff";
      else ctx.fillStyle = "#339933";
      ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    }
  }

  ctx.restore();
}

function screenToWorld(x, y) {
  return {
    x: (x - viewOffset.x) / scale,
    y: (y - viewOffset.y) / scale
  };
}

function worldToTile(x, y) {
  return {
    tx: Math.floor(x),
    ty: Math.floor(y)
  };
}

function isValidCoord(tx, ty) {
  return tx >= 0 && ty >= 0 && tx < MAP_COLS && ty < MAP_ROWS;
}

function isAdjacentToOwned(tx, ty) {
  for (let dy = -3; dy <= 3; dy++) {
    for (let dx = -3; dx <= 3; dx++) {
      const nx = tx + dx;
      const ny = ty + dy;
      if (isValidCoord(nx, ny) && map[ny][nx].owner === "player") {
        return true;
      }
    }
  }
  return false;
}

function claimArea(tx, ty) {
  for (let dy = -2; dy <= 2; dy++) {
    for (let dx = -2; dx <= 2; dx++) {
      const nx = tx + dx;
      const ny = ty + dy;
      if (isValidCoord(nx, ny) && map[ny][nx].type === "land") {
        map[ny][nx].owner = "player";
      }
    }
  }
  hasSpawned = true;
  closeFlagMenu();
  draw();
}

function openFlagMenu(screenX, screenY, tx, ty) {
  pendingClaim = { tx, ty };
  flagMenu.style.left = screenX + "px";
  flagMenu.style.top = screenY + "px";
  flagMenu.style.display = "flex";
}

function closeFlagMenu() {
  flagMenu.style.display = "none";
  pendingClaim = null;
}

flagMenu.onclick = () => {
  if (pendingClaim) {
    claimArea(pendingClaim.tx, pendingClaim.ty);
  }
};

function handleTap(screenX, screenY) {
  const world = screenToWorld(screenX, screenY);
  const { tx, ty } = worldToTile(world.x, world.y);
  if (!isValidCoord(tx, ty)) return;
  const tile = map[ty][tx];
  if (tile.type !== "land") return;
  if (tile.owner === "player") return;
  if (!hasSpawned || isAdjacentToOwned(tx, ty)) {
    openFlagMenu(screenX, screenY, tx, ty);
  }
}

// Mouse Controls
canvas.addEventListener("mousedown", e => {
  isDragging = true;
  dragStart.x = e.clientX;
  dragStart.y = e.clientY;
  dragOffsetStart.x = viewOffset.x;
  dragOffsetStart.y = viewOffset.y;
});
canvas.addEventListener("mousemove", e => {
  if (isDragging) {
    viewOffset.x = dragOffsetStart.x + (e.clientX - dragStart.x);
    viewOffset.y = dragOffsetStart.y + (e.clientY - dragStart.y);
    draw();
  }
});
canvas.addEventListener("mouseup", () => isDragging = false);
canvas.addEventListener("mouseleave", () => isDragging = false);
canvas.addEventListener("click", e => {
  if (!isDragging) handleTap(e.clientX, e.clientY);
});

// Mouse wheel zoom
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomAmount = -e.deltaY * 0.001;
  const oldScale = scale;
  scale += zoomAmount;
  scale = Math.min(10, Math.max(0.5, scale));

  const worldBefore = screenToWorld(e.clientX, e.clientY);
  viewOffset.x += (worldBefore.x * (scale - oldScale));
  viewOffset.y += (worldBefore.y * (scale - oldScale));
  draw();
}, { passive: false });

// Touch zoom (pinch)
let lastDist = null;
canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 1) {
    const t = e.touches[0];
    dragStart.x = t.clientX;
    dragStart.y = t.clientY;
    dragOffsetStart.x = viewOffset.x;
    dragOffsetStart.y = viewOffset.y;
    isDragging = true;
  } else if (e.touches.length === 2) {
    lastDist = getTouchDist(e);
  }
});
canvas.addEventListener("touchmove", e => {
  if (e.touches.length === 1 && isDragging) {
    const t = e.touches[0];
    viewOffset.x = dragOffsetStart.x + (t.clientX - dragStart.x);
    viewOffset.y = dragOffsetStart.y + (t.clientY - dragStart.y);
    draw();
  } else if (e.touches.length === 2) {
    const newDist = getTouchDist(e);
    if (lastDist) {
      const zoomAmount = (newDist - lastDist) * 0.01;
      const oldScale = scale;
      scale += zoomAmount;
      scale = Math.min(10, Math.max(0.5, scale));
      const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      const worldMid = screenToWorld(midX, midY);
      viewOffset.x += worldMid.x * (scale - oldScale);
      viewOffset.y += worldMid.y * (scale - oldScale);
      draw();
    }
    lastDist = newDist;
  }
});
canvas.addEventListener("touchend", e => {
  isDragging = false;
  if (e.touches.length === 0 && e.changedTouches.length === 1) {
    const t = e.changedTouches[0];
    handleTap(t.clientX, t.clientY);
  }
  lastDist = null;
});

function getTouchDist(e) {
  const dx = e.touches[0].clientX - e.touches[1].clientX;
  const dy = e.touches[0].clientY - e.touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// Resize
window.addEventListener("resize", () => {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
  draw();
});

draw();
</script>
</body>
</html>
