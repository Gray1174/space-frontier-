<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Territory Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #flagMenu {
      position: absolute;
      display: none;
      width: 40px;
      height: 40px;
      background: #333;
      border: 2px solid #555;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      font-size: 24px;
      color: white;
      user-select: none;
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="flagMenu">ðŸš©</div>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const flagMenu = document.getElementById("flagMenu");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const TILE_SIZE = 4;
    const MAP_COLS = 200;
    const MAP_ROWS = 100;

    const map = [];
    for (let y = 0; y < MAP_ROWS; y++) {
      const row = [];
      for (let x = 0; x < MAP_COLS; x++) {
        const terrain = Math.random() < 0.12 ? "water" : "land";
        row.push({ owner: null, type: terrain });
      }
      map.push(row);
    }

    let playerSpawned = false;
    let viewOffset = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragOffsetStart = { x: 0, y: 0 };

    function draw() {
      ctx.clearRect(0, 0, width, height);
      for (let y = 0; y < MAP_ROWS; y++) {
        for (let x = 0; x < MAP_COLS; x++) {
          const tile = map[y][x];
          if (tile.type === "water") {
            ctx.fillStyle = "#3377cc";
          } else {
            ctx.fillStyle = tile.owner === "player" ? "blue" : "green";
          }
          ctx.fillRect(
            x * TILE_SIZE + viewOffset.x,
            y * TILE_SIZE + viewOffset.y,
            TILE_SIZE,
            TILE_SIZE
          );
        }
      }
    }

    function worldToTile(x, y) {
      return {
        tx: Math.floor((x - viewOffset.x) / TILE_SIZE),
        ty: Math.floor((y - viewOffset.y) / TILE_SIZE)
      };
    }

    function openFlagMenu(x, y) {
      flagMenu.style.left = x + "px";
      flagMenu.style.top = y + "px";
      flagMenu.style.display = "flex";
    }

    function closeFlagMenu() {
      flagMenu.style.display = "none";
    }

    function spawnPlayer(x, y) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (
            nx >= 0 && ny >= 0 && nx < MAP_COLS && ny < MAP_ROWS &&
            map[ny][nx].type !== "water"
          ) {
            map[ny][nx].owner = "player";
          }
        }
      }
      playerSpawned = true;
      closeFlagMenu();
    }

    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      dragOffsetStart.x = viewOffset.x;
      dragOffsetStart.y = viewOffset.y;
    });

    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        viewOffset.x = dragOffsetStart.x + (e.clientX - dragStart.x);
        viewOffset.y = dragOffsetStart.y + (e.clientY - dragStart.y);
        draw();
      }
    });

    canvas.addEventListener("mouseup", () => {
      isDragging = false;
    });

    canvas.addEventListener("click", (e) => {
      if (!playerSpawned) {
        const { tx, ty } = worldToTile(e.clientX, e.clientY);
        if (map[ty] && map[ty][tx] && map[ty][tx].type === "land") {
          openFlagMenu(e.clientX, e.clientY);
          flagMenu.onclick = () => {
            spawnPlayer(tx, ty);
            draw();
          };
        }
      }
    });

    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        const t = e.touches[0];
        dragStart.x = t.clientX;
        dragStart.y = t.clientY;
        dragOffsetStart.x = viewOffset.x;
        dragOffsetStart.y = viewOffset.y;
        isDragging = true;
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      if (e.touches.length === 1 && isDragging) {
        const t = e.touches[0];
        viewOffset.x = dragOffsetStart.x + (t.clientX - dragStart.x);
        viewOffset.y = dragOffsetStart.y + (t.clientY - dragStart.y);
        draw();
      }
    });

    canvas.addEventListener("touchend", (e) => {
      isDragging = false;
      if (!playerSpawned && e.changedTouches.length === 1) {
        const t = e.changedTouches[0];
        const { tx, ty } = worldToTile(t.clientX, t.clientY);
        if (map[ty] && map[ty][tx] && map[ty][tx].type === "land") {
          openFlagMenu(t.clientX, t.clientY);
          flagMenu.onclick = () => {
            spawnPlayer(tx, ty);
            draw();
          };
        }
      }
    });

    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      draw();
    });

    draw();
  </script>
</body>
</html>
